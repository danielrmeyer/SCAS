/*
Note the code under com.example.symengine was generated by the following command
jextract -I/usr/local/include/symengine -l symengine -t com.example.symengine --output output_dir --include-function basic_new_heap   --include-function basic_free_heap   --include-function symbol_set   --include-function integer_set_si   --include-function basic_add   --include-function basic_pow   --include-function basic_expand   --include-function basic_str   --include-function basic_str_free   --include-struct CRCPBasic_C   /usr/local/include/symengine/cwrapper.h

 */

import com.example.symengine.cwrapper_h
import java.lang.foreign.{Arena, MemorySegment}
import java.nio.charset.StandardCharsets

object SymEngineScalaExample:
  def main(args: Array[String]): Unit =
    try
      // Step 1: Use Arena for memory management
      val arena = Arena.ofConfined()

      // Create a symbol "x"
      val x = cwrapper_h.basic_new_heap()
      if x == null then
        println("Failed to allocate memory for x")
        return

      val nameBytes = "x".getBytes(StandardCharsets.UTF_8)
      val nameSegment = arena.allocate(nameBytes.length)
      nameSegment.asByteBuffer().put(nameBytes)

      cwrapper_h.symbol_set(x, nameSegment)
      println("Symbol 'x' created")

      // Step 2: Set up integer 2 and calculate sqrt(2)
      val two = cwrapper_h.basic_new_heap()
      cwrapper_h.integer_set_si(two, 2)

      val sqrtTwo = cwrapper_h.basic_new_heap()
      cwrapper_h.basic_sqrt(sqrtTwo, two)
      println("Calculated sqrt(2)")

      // Step 3: Create expression (x + sqrt(2))^6
      val xPlusSqrtTwo = cwrapper_h.basic_new_heap()
      cwrapper_h.basic_add(xPlusSqrtTwo, x, sqrtTwo)

      val exponent = cwrapper_h.basic_new_heap()
      cwrapper_h.integer_set_si(exponent, 6)

      val expression = cwrapper_h.basic_new_heap()
      cwrapper_h.basic_pow(expression, xPlusSqrtTwo, exponent)
      println("Created expression (x + sqrt(2))^6")

      // Step 4: Expand the expression
      val expandedExpr = cwrapper_h.basic_new_heap()
      cwrapper_h.basic_expand(expandedExpr, expression)

      // Step 5: Convert expanded expression to string and print
      val resultStr = cwrapper_h.basic_str(expandedExpr)

      if resultStr != null then
        // Limit segment size to 1024 bytes to avoid overflow issues
        val buffer = resultStr.asSlice(0, 1024).asByteBuffer()

        // Find the null-terminator byte
        var length = 0
        while buffer.get(length) != 0 && length < buffer.limit() do
          length += 1

        // Decode only the actual string content up to the null terminator
        val expandedExpression = StandardCharsets.UTF_8.decode(buffer.limit(length)).toString
        println(s"Expanded expression: $expandedExpression")
        cwrapper_h.basic_str_free(resultStr)
      else
        println("Failed to retrieve string representation of expanded expression")

      // Clean up
      cwrapper_h.basic_free_heap(x)
      cwrapper_h.basic_free_heap(two)
      cwrapper_h.basic_free_heap(sqrtTwo)
      cwrapper_h.basic_free_heap(xPlusSqrtTwo)
      cwrapper_h.basic_free_heap(exponent)
      cwrapper_h.basic_free_heap(expression)
      cwrapper_h.basic_free_heap(expandedExpr)

    catch case e: Throwable =>
      println(s"An error occurred: ${e.getMessage}")
